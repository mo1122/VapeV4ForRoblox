-- Credits to Inf Yield & all the other scripts that helped me make bypasses
local GuiLibrary = shared.GuiLibrary
local players = game:GetService("Players")
local lplr = players.LocalPlayer
local workspace = game:GetService("Workspace")
local lighting = game:GetService("Lighting")
local cam = workspace.CurrentCamera
local targetinfo = shared.VapeTargetInfo
local uis = game:GetService("UserInputService")
local mouse = lplr:GetMouse()
local robloxfriends = {}
local bedwars = {}
local getfunctions
local origC0 = nil
local matchState = 0
local kit = ""
local antivoidypos = 0

local function getItem(itemName)
	for i5, v5 in pairs(bedwars["getInventory"](lplr)["items"]) do
		if v5["itemType"] == itemName then
			return v5
		end
	end
	return nil
end

local function getSword()
	for i5, v5 in pairs(bedwars["getInventory"](lplr)["items"]) do
		if v5["itemType"]:find("sword") or v5["itemType"]:find("blade") then
			return v5
		end
	end
	return nil
end


local function getwool()
	for i5, v5 in pairs(bedwars["getInventory"](lplr)["items"]) do
		if v5["itemType"]:match("wool") then
			return v5["itemType"]
		end
	end
	return nil
end

local function scanforbeds()
	local blocktab = game.Workspace.Map.Blocks:GetChildren()
	bedwars["BedTable"] = {}
	for i = 1, #blocktab do
		local obj = blocktab[i]
		if obj.Name == "bed" then
			bedwars["BedTable"][#bedwars["BedTable"] + 1] = obj
			if antivoidypos == 0 then
				antivoidypos = obj.Position.Y
			end
		end
	end  
end

getfunctions = function()
	for i,v in pairs(getgc(true)) do
		if type(v) == "table" then
			if rawget(v, "blocksFolder") then
				bedwars["BlockController"] = v
			end
			if rawget(v, "ClientBlockEngine") then
				bedwars["BlockEngine"] = v["ClientBlockEngine"]
			end
			if rawget(v, "BlockPlacer") then
				bedwars["BlockController2"] = v["BlockPlacer"]
			end
			if rawget(v, "BlockBreaker") then
				bedwars["BlockController3"] = v["BlockBreaker"]
			end
			if rawget(v, "getInventory") then
				bedwars["getInventory"] = v["getInventory"]
			end
			if rawget(v, "Client") and bedwars["Client"] == nil then
				bedwars["Client"] = v.Client
			end
			if rawget(v, "ClientStore") and bedwars["ClientStore"] == nil then
				bedwars["ClientStore"] = v.ClientStore
			end
			if rawget(v, "VictorySection") then
				bedwars["VictoryScreen"] = v["VictorySection"]
			end
			if rawget(v, "calculateImportantLaunchValues") then
				bedwars["BowTable"] = v
			end
			if rawget(v, "kbDirectionStrength") then
				bedwars["KnockbackTable"] = v
			end
			if rawget(v, "ViewmodelController") then
				bedwars["ViewmodelController"] = v["ViewmodelController"]
			end
			if rawget(v, "BedwarsShop") then
				bedwars["Shop"] = v["BedwarsShop"]
			end
			if rawget(v, "SoundManager") then
				bedwars["SoundManager"] = v["SoundManager"]
			end
			if rawget(v, "SetSelectedShopItem") then
				bedwars["SetSelectedShopItem"] = v["SetSelectedShopItem"]
			end
			if rawget(v, "getItemMeta") then
				bedwars["getIcon"] = function(item, showinv)
					local itemmeta = v["getItemMeta"](item["itemType"])
					if itemmeta and showinv then
						return itemmeta.image
					end
					return ""
				end
			end
			if rawget(v, "ShieldController") and getmetatable(rawget(v, "ShieldController")) then
				for i2,v2 in pairs(debug.getconstants(debug.getprotos(getmetatable(v["ShieldController"])["raiseShield"])[1])) do
					if tostring(v2):match("-") or tostring(v2):match("UseShield") then
						bedwars["raiseShield"] = function()
							game:GetService("ReplicatedStorage").rbxts_include.node_modules.net.out._NetManaged[tostring(v2)]:FireServer({
								["raised"] = true
							})
						end
					end
				end
			end
			if rawget(v, "performHeal") then
				for i2,v2 in pairs(debug.getconstants(v["performHeal"])) do
					if tostring(v2):match("-") or tostring(v2):match("PlayGuitar") then
						bedwars["GuitarRemote"] = v2
					end
				end
			end
			if rawget(v, "SwordController") then
				bedwars["SwordController"] = v["SwordController"]
			end
			if rawget(v, "BalloonController") then
				bedwars["BalloonController"] = v["BalloonController"]
			end
			if rawget(v, "swingSwordAtMouse") then
				bedwars["SwingSword"] = v["swingSwordAtMouse"]
			end
			if rawget(v, "swingSwordInRegion") then
				bedwars["SwingSwordRegion"] = v["swingSwordInRegion"]
			end
			if rawget(v, "CombatConstant") then
				bedwars["CombatConstant"] = v["CombatConstant"]
			end
			if rawget(v, "attackEntity") then
				bedwars["attackEntity"] = v["attackEntity"]
			end
			if rawget(v, "requestSelfDamage") then
				bedwars["damageTable"] = v
			end
			if rawget(v, "GamePlayerUtil") then
				bedwars["PlayerUtil"] = v["GamePlayerUtil"]
			end
			for i2,v2 in pairs(v) do
				if tostring(i2):match("sprinting") and type(v2) == "boolean" then
					bedwars["sprintTable"] = v
				  end
			end
		end
	end

	if (bedwars["PlayerUtil"] and bedwars["Shop"] and bedwars["SoundManager"] and bedwars["SetSelectedShopItem"] and bedwars["ViewmodelController"] and bedwars["GuitarRemote"] and bedwars["BalloonController"] and bedwars["SwingSwordRegion"] and bedwars["CombatConstant"] and bedwars["SwingSword"] and bedwars["BowTable"] and bedwars["getInventory"] and bedwars["raiseShield"] and bedwars["BlockController"] and bedwars["BlockEngine"] and bedwars["BlockController2"] and bedwars["BlockController3"] and bedwars["SwordController"] and bedwars["attackEntity"] and bedwars["damageTable"] and bedwars["sprintTable"]) or (not shared.VapeExecuted) then
		repeat wait() until lplr.Team ~= nil
		local blocktable
		bedwars["placeBlock"] = function(newpos)
			if blocktable == nil and getwool() then
				blocktable = bedwars["BlockController2"].new(bedwars["BlockEngine"], getwool())
			end
			if blocktable then
				if getmetatable(bedwars["BlockController"])["isAllowedPlacement"](bedwars["BlockController"], lplr, getwool(), Vector3.new(newpos.X / 3, newpos.Y / 3, newpos.Z / 3)) and getItem(getwool()) then
					bedwars["BlockController2"].placeBlock(blocktable, Vector3.new(newpos.X / 3, newpos.Y / 3, newpos.Z / 3))
				end
			end
		end
		spawn(function()
			bedwars["BedTable"] = {}
			scanforbeds()
			repeat wait(1) scanforbeds() until #bedwars["BedTable"] > 0
		end)
		bedwars["ClientStore"].changed:connect(function(p3, p4)
			if p3.Game ~= p4.Game then
				if p3.Game.matchState ~= p4.Game.matchState then
					matchState = p3.Game.matchState
					if matchState ~= 0 then
						kit = rawget(bedwars["ClientStore"]:getState()["Bedwars"], "kit")
					end
				end
			end
		end)
		matchState = bedwars["ClientStore"]:getState().Game.matchState
		if matchState ~= 0 then
			kit = rawget(bedwars["ClientStore"]:getState()["Bedwars"], "kit")
		end
	else
		wait(1)
	--	print(bedwars["assetTable"],bedwars["ZiplineRemote"],bedwars["HitProjectile"],bedwars["FireProjectile"],bedwars["getInventory"],bedwars["raiseShield"],bedwars["BlockController"],bedwars["BlockEngine"],bedwars["BlockController2"],bedwars["SwordController"],bedwars["attackEntity"],bedwars["damageTable"],bedwars["sprintTable"])
		getfunctions()
	end
end

local function makerandom(min, max)
	return Random.new().NextNumber(Random.new(), min, max)
end

getfunctions()
bedwars["breakBlock"] = function(pos)
    game:GetService("ReplicatedStorage").rbxts_include.node_modules.net.out._NetManaged.BreakBlock:InvokeServer({
        ["blockRef"] = {
            ["blockPosition"] = Vector3.new(math.floor(pos.X / 3), math.floor(pos.Y / 3), math.floor(pos.Z / 3))
        },
        ["hitPosition"] = pos + Vector3.new(makerandom(-0.2, 0.2), makerandom(-0.2, 0.2), makerandom(-0.2, 0.2)),
        ["hitNormal"] = Vector3.new(1, 0, 0)
    })
end	

local function friendCheck(plr)
	if not robloxfriends[plr.UserId] then
		if lplr:IsFriendsWith(plr.UserId) then
			table.insert(robloxfriends, plr.Name)
			robloxfriends[plr.UserId] = true
		end
	end
	return (GuiLibrary["ObjectsThatCanBeSaved"]["Use FriendsToggle"]["Api"]["Enabled"] and ((GuiLibrary["ObjectsThatCanBeSaved"]["Use Roblox FriendsToggle"]["Api"]["Enabled"] and table.find(robloxfriends, plr.Name) == nil) and table.find(GuiLibrary["FriendsObject"]["Friends"], plr.Name) == nil) or GuiLibrary["ObjectsThatCanBeSaved"]["Use FriendsToggle"]["Api"]["Enabled"] == false)
end

shared.vapeteamcheck = function(plr)
	return (GuiLibrary["ObjectsThatCanBeSaved"]["Teams by colorToggle"]["Api"]["Enabled"] and (bedwars["PlayerUtil"].getGamePlayer(lplr):getTeamId() ~= bedwars["PlayerUtil"].getGamePlayer(plr):getTeamId() or (lplr.Team == nil or #lplr.Team:GetPlayers() == #game:GetService("Players"):GetChildren())) or GuiLibrary["ObjectsThatCanBeSaved"]["Teams by colorToggle"]["Api"]["Enabled"] == false)
end

local function targetCheck(plr, check)
	return (check and plr.Character.Humanoid.Health > 0 and plr.Character:FindFirstChild("ForceField") == nil or check == false)
end

local function isAlive(plr)
	if plr then
		return plr and plr.Character and plr.Character.Parent ~= nil and plr.Character:FindFirstChild("HumanoidRootPart") and plr.Character:FindFirstChild("Head") and plr.Character:FindFirstChild("Humanoid")
	end
	return lplr and lplr.Character and lplr.Character.Parent ~= nil and lplr.Character:FindFirstChild("HumanoidRootPart") and lplr.Character:FindFirstChild("Head") and lplr.Character:FindFirstChild("Humanoid")
end

local function getEquipped()
	local type = ""
	local obj = (isAlive() and lplr.Character:FindFirstChild("HandInvItem") and lplr.Character.HandInvItem.Value or nil)
	if obj then
		if obj.Name:find("sword") or obj.Name:find("blade") then
			type = "sword"
		end
		if obj.Name:find("wool") then
			type = "block"
		end
		if obj.Name:find("bow") then
			type = "bow"
		end
	end
    return {["Object"] = obj, ["Type"] = type}
end

local function nakedcheck(plr)
	local inventory = bedwars["getInventory"](plr)
	return inventory["armor"][4] ~= nil and inventory["armor"][5] ~= nil and inventory["armor"][6] ~= nil
end

local function isPlayerTargetable(plr, target, friend, team)
    return plr ~= lplr and GuiLibrary["ObjectsThatCanBeSaved"]["PlayersToggle"]["Api"]["Enabled"] and plr and isAlive(plr) and targetCheck(plr, target) and (GuiLibrary["ObjectsThatCanBeSaved"]["Ignore nakedToggle"]["Api"]["Enabled"] and nakedcheck(plr) or GuiLibrary["ObjectsThatCanBeSaved"]["Ignore nakedToggle"]["Api"]["Enabled"] == false) and ((team and plr.Team == lplr.Team) or (team == nil and shared.vapeteamcheck(plr)))
end

local function vischeck(pos, pos2, ignore)
	local vistab = cam:GetPartsObscuringTarget({pos, pos2}, ignore)
	for i,v in pairs(vistab) do
		print(i,v:GetFullName())
	end
	return not unpack(vistab)
end

local function GetAllNearestHumanoidToPosition(distance, amount)
	local returnedplayer = {}
	local currentamount = 0
    if isAlive() then
        for i, v in pairs(players:GetChildren()) do
            if isPlayerTargetable(v, true, true) and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Head") and currentamount < amount then
                local mag = (lplr.Character.HumanoidRootPart.Position - v.Character.HumanoidRootPart.Position).magnitude
                if mag <= distance then
                    table.insert(returnedplayer, v)
					currentamount = currentamount + 1
                end
            end
        end
	end
	return returnedplayer
end

local function GetNearestHumanoidToPosition(distance)
	local closest, returnedplayer = distance, nil
    if isAlive() then
        for i, v in pairs(players:GetChildren()) do
            if isPlayerTargetable(v, true, false) and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Head") then
                local mag = (lplr.Character.HumanoidRootPart.Position - v.Character.HumanoidRootPart.Position).magnitude
                if mag <= closest then
                    closest = mag
                    returnedplayer = v
                end
            end
        end
	end
	return returnedplayer
end

local function GetNearestHumanoidToMouse(distance, checkvis)
    local closest, returnedplayer = distance, nil
    if isAlive() then
        for i, v in pairs(players:GetChildren()) do
            if isPlayerTargetable(v, true, true) and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Head") and (checkvis == false or checkvis and (vischeck(v.Character, "Head") or vischeck(v.Character, "HumanoidRootPart"))) then
                local vec, vis = cam:WorldToScreenPoint(v.Character.HumanoidRootPart.Position)
                if vis then
                    local mag = (uis:GetMouseLocation() - Vector2.new(vec.X, vec.Y)).magnitude
                    if mag <= closest then
                        closest = mag
                        returnedplayer = v
                    end
                end
            end
        end
    end
    return returnedplayer
end

GuiLibrary["RemoveObject"]("AimAssistOptionsButton")
local aimfov = {["Value"] = 1}
local aimvischeck = {["Enabled"] = false}
local aimheadshotchance = {["Value"] = 1}
local aimhitchance = {["Value"] = 1}
local aimonlybow = {["Enabled"] = false}
local tar = nil
local hook
local AimAssist = GuiLibrary["ObjectsThatCanBeSaved"]["CombatWindow"]["Api"].CreateOptionsButton("AimAssist", function() 
	hook = bedwars["BowTable"]["calculateImportantLaunchValues"]
	bedwars["BowTable"]["calculateImportantLaunchValues"] = function(bowtable, projmeta, worldmeta)
		local plr = GetNearestHumanoidToMouse(aimfov["Value"], false)
		if plr and (math.floor(Random.new().NextNumber(Random.new(), 0, 1) * 100)) <= aimhitchance["Value"] then
			tar = (math.floor(Random.new().NextNumber(Random.new(), 0, 1) * 100)) <= aimheadshotchance["Value"] and plr.Character.Head or plr.Character.HumanoidRootPart
		else
			tar = nil
		end
		if tar and (aimonlybow["Enabled"] and getEquipped()["Type"] == "bow" or (not aimonlybow["Enabled"])) then
				local launchPosition = bowtable:getLaunchPosition()
				if not launchPosition then
					return nil
				end
				local realLaunchPosition = launchPosition + Vector3.new(0, 2, 0)
				local proj = projmeta:getProjectileMeta();
				if p26 then
					local v58 = proj.predictionLifetimeSec;
				else
					v58 = proj.lifetimeSec;
				end;
				local v59 = v58;
				if v59 == nil then
					v59 = 3;
				end;
				local v60 = proj.launchVelocity;
				if v60 == nil then
					v60 = 100;
				end;
				local projGravity = proj.gravitationalAcceleration;
				if projGravity == nil then
					projGravity = 196.2;
				end;
				local realTargetPosition = tar.Position + ((Vector3.new(plr.Character.HumanoidRootPart.Velocity.X, 0, plr.Character.HumanoidRootPart.Velocity.Z) / 5) * ((realLaunchPosition - tar.Position).magnitude / v60))
				local l__CFrame__62 = workspace.CurrentCamera.CFrame;
				local v65 = Ray.new(realLaunchPosition, (realTargetPosition + Vector3.new(-1, (realLaunchPosition - realTargetPosition).magnitude / ((v60 * projmeta.velocityMultiplier) / 10), 0) - realLaunchPosition).unit)
				return {
					initialVelocity = (realLaunchPosition + (v65.Unit.Direction).Unit * ((l__CFrame__62.Position - realLaunchPosition).Magnitude * 5) - realLaunchPosition).Unit * (v60 * projmeta.velocityMultiplier), 
					positionFrom = realLaunchPosition, 
					deltaT = v59, 
					gravitationalAcceleration = projGravity * projmeta.gravityMultiplier
				};
		else
			return hook(bowtable, projmeta, worldmeta)
		end
	end
end, function() 
	bedwars["BowTable"]["calculateImportantLaunchValues"] = hook
	tar = nil 
	hook = nil
end, true, function() 
	return " BedWars"
end, "Auto Aims bow at closest player.")
aimfov = AimAssist.CreateSlider("FOV", 1, 1000, function(val) end, 1000)
aimhitchance = AimAssist.CreateSlider("Hit Chance", 1, 100, function(val) end, 100)
aimheadshotchance = AimAssist.CreateSlider("Headshot Chance", 1, 100, function(val) end, 100)
aimonlybow = AimAssist.CreateToggle("Only Bow", function() end, function() end, true)

GuiLibrary["RemoveObject"]("AutoClickerOptionsButton")
local autoclickercps = {["GetRandomValue"] = function() return 1 end}
local autoclicker = {["Enabled"] = false}
local autoclickertick = tick()
autoclicker = GuiLibrary["ObjectsThatCanBeSaved"]["CombatWindow"]["Api"].CreateOptionsButton("AutoClicker", function()
	game:GetService("RunService"):BindToRenderStep("AutoClicker", 1, function() 
		if isAlive() and uis:IsMouseButtonPressed(0) and autoclickertick <= tick() and getEquipped()["Type"] == "sword" and bedwars["ClientStore"]:getState().App.shownApp <= 0 and GuiLibrary["MainGui"].ClickGui.Visible == false and matchState ~= 0 then
			bedwars["SwingSword"](bedwars["SwordController"])
			autoclickertick = tick() + (1 / autoclickercps["GetRandomValue"]()) * Random.new().NextNumber(Random.new(), 0.75, 1)
		end
	end)
end, function() game:GetService("RunService"):UnbindFromRenderStep("AutoClicker") end, true, function() return "" end, "Clicks for you")
autoclickercps = autoclicker.CreateTwoSlider("CPS", 1, 20, function(val) end, false, 8, 12)

GuiLibrary["RemoveObject"]("ReachOptionsButton")
local oldreach1 = bedwars["CombatConstant"].RAYCAST_SWORD_CHARACTER_DISTANCE
local Reach = GuiLibrary["ObjectsThatCanBeSaved"]["CombatWindow"]["Api"].CreateOptionsButton("Reach", function()
	bedwars["CombatConstant"].RAYCAST_SWORD_CHARACTER_DISTANCE = oldreach1 * 3
end, function() 
	debug.setupvalue(bedwars["SwingSwordRegion"], 3, 3)
	bedwars["CombatConstant"].RAYCAST_SWORD_CHARACTER_DISTANCE = oldreach1
end, true, function() return "" end, "Extends attack reach")

local velohorizontal = {["Value"] = 100}
local velovertical = {["Value"] = 100}
local oldhori = bedwars["KnockbackTable"]["kbDirectionStrength"]
local oldvert = bedwars["KnockbackTable"]["kbUpwardStrength"]
local Velocity = GuiLibrary["ObjectsThatCanBeSaved"]["CombatWindow"]["Api"].CreateOptionsButton("Velocity", function()
	bedwars["KnockbackTable"]["kbDirectionStrength"] = oldhori * (velohorizontal["Value"] / 100)
	bedwars["KnockbackTable"]["kbUpwardStrength"] = oldvert * (velovertical["Value"] / 100)
end, function() 
	bedwars["KnockbackTable"]["kbDirectionStrength"] = oldhori
	bedwars["KnockbackTable"]["kbUpwardStrength"] = oldvert
end, true, function() return "" end, "Reduces knockback taken")
velohorizontal = Velocity.CreateSlider("Horizontal", 0, 100, function(val) bedwars["KnockbackTable"]["kbDirectionStrength"] = oldhori * (val / 100) end, 100)
velovertical = Velocity.CreateSlider("Vertical", 0, 100, function(val) bedwars["KnockbackTable"]["kbUpwardStrength"] = oldvert * (val / 100) end, 100)

local Sprint = {["Enabled"] = false}
Sprint = GuiLibrary["ObjectsThatCanBeSaved"]["CombatWindow"]["Api"].CreateOptionsButton("Sprint", function()
	spawn(function()
		repeat
			wait()
			if bedwars["sprintTable"].sprinting == false then
				getmetatable(bedwars["sprintTable"])["startSprinting"](bedwars["sprintTable"])
			end
		until Sprint["Enabled"] == false
	end)
end, function() end, true, function() return "" end, "Sets your sprinting to true")

local antivoidpart
local AntiVoid = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton("AntiVoid", function()
	spawn(function()
		repeat wait() until antivoidypos ~= 0
		antivoidpart = Instance.new("Part")
		antivoidpart.CanCollide = true
		antivoidpart.Size = Vector3.new(10000, 1, 10000)
		antivoidpart.Anchored = true
		antivoidpart.Transparency = 0.5
		antivoidpart.Position = Vector3.new(0, antivoidypos - 20, 0)
		antivoidpart.Touched:connect(function(touchedpart)
			if touchedpart.Parent == lplr.Character and isAlive() then
				lplr.Character.HumanoidRootPart.Velocity = Vector3.new(0, 100, 0)
			end
		end)
		antivoidpart.Parent = game.Workspace
	end)
end, function() antivoidpart:Remove() end, true, function() return "" end, "Gives you a chance to get on land.")


local function getScaffold(vec)
    return Vector3.new(math.floor((vec.X / 3) + 0.5) * 3, math.floor((vec.Y / 3) + 0.5) * 3, math.floor((vec.Z / 3) + 0.5) * 3) 
end

local function scaffoldBlock(newpos)
    bedwars["placeBlock"](newpos)
end

local swords = {
	["wood_sword"] = "stone_sword",
	["stone_sword"] = "iron_sword",
	["iron_sword"] = "diamond_sword",
	["diamond_sword"] = "emerald_sword"
}
local AutoBuy = {["Enabled"] = false}
local AutoBuyArmor = {["Enabled"] = true}
local AutoBuySword = {["Enabled"] = true}
local AutoBuyUpgrades = {["Enabled"] = true}

local BuyCheck = function() end
BuyCheck = function()
	if AutoBuy["Enabled"] then
		local ExecuteInventory = bedwars["getInventory"](lplr)
		local NextArmor = ExecuteInventory.armor[5] and bedwars["Shop"].getShopItem(ExecuteInventory.armor[5].itemType)["nextTier"] or (ExecuteInventory.armor[5] == nil and "leather_chestplate")
		local NextSword = getSword() and swords[getSword().itemType]
		local ProtectionUpgrade = bedwars["Shop"].getTeamUpgrade("armor")
		local SharpnessUpgrade = bedwars["Shop"].getTeamUpgrade("damage")
		if AutoBuySword["Enabled"] and NextSword then
			local NextSwordTable = bedwars["Shop"].getShopItem(NextSword)
			local NextSwordCurrency = getItem(NextSwordTable["currency"])
			if NextSwordCurrency and NextSwordCurrency["amount"] >= NextSwordTable["price"] then
				bedwars["Client"]:Get("BedwarsPurchaseItem"):CallServerAsync({
					shopItem = NextSwordTable
				}):andThen(function(p11)
					if p11 then
						bedwars["SoundManager"]:playSound(12)
						bedwars["ClientStore"]:dispatch({
							type = "BedwarsAddItemPurchased", 
							itemType = NextSwordTable.itemType
						});
					end
					NextSword = swords[NextSwordTable["itemType"]]
					if p11 then
						BuyCheck()
					end
				end)
			end
		end
		if AutoBuyArmor["Enabled"] and NextArmor then
			local NextArmorTable = bedwars["Shop"].getShopItem(NextArmor)
			local NextArmorCurrency = getItem(NextArmorTable["currency"])
			if NextArmorCurrency and NextArmorCurrency["amount"] >= NextArmorTable["price"] then
				bedwars["Client"]:Get("BedwarsPurchaseItem"):CallServerAsync({
					shopItem = NextArmorTable
				}):andThen(function(p11)
					if p11 then
						bedwars["SoundManager"]:playSound(12)
						bedwars["ClientStore"]:dispatch({
							type = "BedwarsAddItemPurchased", 
							itemType = NextArmorTable.itemType
						});
						if NextArmorTable.nextTier then
							local l__ShopItems__5 = bedwars["Shop"].ShopItems;
							local function v6(p12)
								return p12.itemType == NextArmorTable.nextTier;
							end;
							local v7 = nil;
							for v8, v9 in ipairs(l__ShopItems__5) do
								if v6(v9, v8 - 1, l__ShopItems__5) == true then
									v7 = v9;
									break;
								end;
							end;
							bedwars["SetSelectedShopItem"](v7);
							return;
						elseif NextArmorTable.tiered or NextArmorTable.lockAfterPurchase then
		
						end
					end
					NextArmor = NextArmorTable["nextTier"]
					if p11 then
						BuyCheck()
					end
				end)
			end
		end
		if AutoBuyUpgrades["Enabled"] then
			local CurrentUpgrades = bedwars["ClientStore"]:getState()["Bedwars"]["teamUpgrades"]
			local ProtNewTier = ProtectionUpgrade["tiers"][CurrentUpgrades["armor"] and CurrentUpgrades["armor"] + 2 or 1]
			local SharpNewTier = SharpnessUpgrade["tiers"][CurrentUpgrades["damage"] and CurrentUpgrades["damage"] + 2 or 1]
			local ProtCurrency = getItem(ProtNewTier["currency"])
			if ProtCurrency and ProtCurrency["amount"] >= ProtNewTier["price"] then
				bedwars["Client"]:Get("BedwarsPurchaseTeamUpgrade"):CallServerAsync({
					upgradeId = "armor", 
					tier = CurrentUpgrades["armor"] and CurrentUpgrades["armor"] + 1 or 0
				}):andThen(function()
					bedwars["SoundManager"]:playSound(11)
				end)
			end
			local SharpCurrency = getItem(SharpNewTier["currency"])
			if SharpCurrency and SharpCurrency["amount"] >= SharpNewTier["price"] then
				bedwars["Client"]:Get("BedwarsPurchaseTeamUpgrade"):CallServerAsync({
					upgradeId = "damage", 
					tier = CurrentUpgrades["damage"] and CurrentUpgrades["damage"] + 1 or 0
				}):andThen(function()
					bedwars["SoundManager"]:playSound(11)
				end)
			end
		end
	end
end

bedwars["ClientStore"].changed:connect(function(p3, p4)
	if p3.Inventory.observedPlayer == lplr and p3.Inventory.observedPlayer ~= p4.Inventory.observedPlayer then
		BuyCheck()
	end
end)
bedwars["Client"]:Get("PickupItemEvent"):Connect(BuyCheck)
AutoBuy = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton("AutoBuy", BuyCheck, function() end, true)
AutoBuyArmor = AutoBuy.CreateToggle("Buy Armor", function() end, function() end, true)
AutoBuySword = AutoBuy.CreateToggle("Buy Sword", function() end, function() end, true)
AutoBuyUpgrades = AutoBuy.CreateToggle("Buy Team Upgrades", function() end, function() end, true)

GuiLibrary["RemoveObject"]("LongJumpOptionsButton")
GuiLibrary["RemoveObject"]("KillauraOptionsButton")
local killaurarange = {["Value"] = 1}
local killauraangle = {["Value"] = 90}
local killauratargets = {["Value"] = 10}
local killauramouse = {["Enabled"] = false}
local killauracframe = {["Enabled"] = false}
local killauraautoblock = {["Enabled"] = false}
local killauragui = {["Enabled"] = false}
local Killaura = {["Enabled"] = false}
local killauradelay = 0
local Killauranear = false
local killauraplaying = false
local oldplay = function() end
Killaura = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton("Killaura", function()
	oldplay = bedwars["ViewmodelController"]["playAnimation"]
	bedwars["ViewmodelController"]["playAnimation"] = function(Self, id, ...)
		if id == 5 and killauranear and killauraautoblock["Enabled"] and isAlive() and kit == "shielder" then
			pcall(function()
				if origC0 == nil then
					origC0 = cam.Viewmodel.RightHand.RightWrist.C0
				end
				if killauraplaying == false then
					killauraplaying = true
					game:GetService("TweenService"):Create(cam.Viewmodel.RightHand.RightWrist, TweenInfo.new(0.1), {C0 = origC0 * CFrame.new(0.7, -1, 0.6) * CFrame.Angles(-math.rad(45), math.rad(55), -math.rad(70))}):Play()
					wait(0.05)
					game:GetService("TweenService"):Create(cam.Viewmodel.RightHand.RightWrist, TweenInfo.new(0.1), {C0 = origC0 * CFrame.new(0.7, -1, 0.6) * CFrame.Angles(-math.rad(45), math.rad(105), -math.rad(70))}):Play()
					wait(0.05)
					killauraplaying = false
				end
			end)
			return nil
		else
			return oldplay(Self, id, ...)
		end
	end
	game:GetService("RunService"):BindToRenderStep("Killaura", 1, function() 
		local targettable = {}
		local targetsize = 0
		if (killauradelay <= tick()) and matchState ~= 0 then
			local plrs = GetAllNearestHumanoidToPosition(killaurarange["Value"], killauratargets["Value"])
			if #plrs <= 0 then
				killauranear = false
				pcall(function()
					if origC0 == nil then
						origC0 = cam.Viewmodel.RightHand.RightWrist.C0
					end
					if cam.Viewmodel.RightHand.RightWrist.C0 ~= origC0 then
						game:GetService("TweenService"):Create(cam.Viewmodel.RightHand.RightWrist, TweenInfo.new(0.1), {C0 = origC0}):Play()
					end
				end)
			end
				for i,plr in pairs(plrs) do
					if isAlive() and getEquipped()["Type"] == "sword" and (killauramouse["Enabled"] and uis:IsMouseButtonPressed(0) or (not killauramouse["Enabled"])) and (killauragui["Enabled"] and (bedwars["ClientStore"]:getState().App.shownApp <= 0 and GuiLibrary["MainGui"].ClickGui.Visible == false) or (not killauragui["Enabled"])) then
						if plr.Character.PrimaryPart and lplr.Character.PrimaryPart then
							killauranear = true
							if killauraautoblock["Enabled"] and kit == "shielder" then
								spawn(bedwars["raiseShield"])
							end
							if killauracframe["Enabled"] then
								lplr.Character:SetPrimaryPartCFrame(CFrame.new(lplr.Character.PrimaryPart.Position, Vector3.new(plr.Character:FindFirstChild("HumanoidRootPart").Position.X, lplr.Character.PrimaryPart.Position.Y, plr.Character:FindFirstChild("HumanoidRootPart").Position.Z)))
							end
							if lplr.Character.Humanoid.SeatPart then
								lplr.Character.Humanoid.SeatPart.CFrame = CFrame.new(lplr.Character.Humanoid.SeatPart.Position, Vector3.new(plr.Character:FindFirstChild("HumanoidRootPart").Position.X, lplr.Character.Humanoid.SeatPart.Position.Y, plr.Character:FindFirstChild("HumanoidRootPart").Position.Z))
							end
							targettable[plr.Name] = {
								["UserId"] = plr.UserId,
								["Health"] = plr.Character.Humanoid.Health,
								["MaxHealth"] = plr.Character.Humanoid.MaxHealth
							}
							targetsize = targetsize + 1
							killauradelay = tick() + 0.1
							bedwars["attackEntity"](bedwars["SwordController"], {["instance"] = plr.Character, ["player"] = plr, ["getInstance"] = function() return plr.Character end}, Ray.new(lplr.Character.HumanoidRootPart.Position, plr.Character.HumanoidRootPart.Position).Unit.Direction)	
						end
					else
						killauranear = false
						pcall(function()
							if origC0 == nil then
								origC0 = cam.Viewmodel.RightHand.RightWrist.C0
							end
							if cam.Viewmodel.RightHand.RightWrist.C0 ~= origC0 then
								game:GetService("TweenService"):Create(cam.Viewmodel.RightHand.RightWrist, TweenInfo.new(0.1), {C0 = origC0}):Play()
							end
						end)
					end
				end
				if getEquipped()["Type"] ~= "bow" then
					targetinfo.UpdateInfo(targettable, targetsize)
				end
		end
	end)
end, function() 
	killauranear = false
	bedwars["ViewmodelController"]["playAnimation"] = oldplay
	oldplay = nil
	pcall(function()
		cam.Viewmodel.RightHand.RightWrist.C0 = origC0
	end)
	game:GetService("RunService"):UnbindFromRenderStep("Killaura") 
end, true, function()
	return " BedWars"
end, "Attack players around you\nwithout aiming at them.")
killaurarange = Killaura.CreateSlider("Attack range", 1, 14, function(val) end, 14)
killauraangle = Killaura.CreateSlider("Max angle", 1, 360, function(val) end, 360)
killauratargets = Killaura.CreateSlider("Max targets", 1, 10, function(val) end, 10)
killauraautoblock = Killaura.CreateToggle("AutoBlock", function() end, function() end)
killauramouse = Killaura.CreateToggle("Require mouse down", function() end, function() end)
killauragui = Killaura.CreateToggle("GUI Check", function() end, function() end)
killauracframe = Killaura.CreateToggle("Face target", function() end, function() end)

local bednukerrange = {["Value"] = 1}
local BedNuker = {["Enabled"] = false}
BedNuker = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton("BedNuker", function()
	spawn(function()
		repeat
			wait(0.2)
			local tab = bedwars["BedTable"]
			for i = 1, #tab do
				local obj = tab[i]
				if isAlive() then
					if obj and obj.Covers.BrickColor ~= lplr.Team.TeamColor then
						if (lplr.Character.HumanoidRootPart.Position - obj.Position).magnitude <= bednukerrange["Value"] then
							bedwars["breakBlock"](obj.Position + Vector3.new(0, 3, 0))
							bedwars["breakBlock"](obj.Position)
						end
					else
						tab[i] = nil
					end
				end
			end
		until BedNuker["Enabled"] == false
	end)
end, function() end, true)
bednukerrange = BedNuker.CreateSlider("Break range", 1, 20, function(val) end, 20)

local fastbreak = {["Enabled"] = true}
local oldbreakfunction
fastbreak = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton("FastBreak", function()
	oldbreakfunction = bedwars["BlockController3"]["hitBlock"] 
	bedwars["BlockController3"]["hitBlock"] = function(block, maid, ray)
		block.blockHealth = 0
		return oldbreakfunction(block, maid, ray)
	end
end, function()
	bedwars["BlockController3"]["hitBlock"] = oldbreakfunction
	oldbreakfunction = nil
end, true)

GuiLibrary["RemoveObject"]("SpeedOptionsButton")
local speedval = {["Value"] = 1}
local speedjump = {["Enabled"] = false}
local bodyvelo
local Scaffold = {["Enabled"] = false}
local speed = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton("Speed", function()
	game:GetService("RunService"):BindToRenderStep("Speed", 1, function(delta)
		if isAlive() and matchState ~= 0 then
			if (bodyvelo == nil or bodyvelo ~= nil and bodyvelo.Parent ~= lplr.Character.HumanoidRootPart) then
				bodyvelo = Instance.new("BodyVelocity")
				bodyvelo.Parent = lplr.Character.HumanoidRootPart
				bodyvelo.MaxForce = Vector3.new(100000, 0, 100000)
			else
				bodyvelo.Velocity = lplr.Character.Humanoid.MoveDirection * speedval["Value"]
			end
			if speedjump["Enabled"] and killauranear and (not Scaffold["Enabled"]) then
				if (lplr.Character.Humanoid:GetState() == Enum.HumanoidStateType.Running or lplr.Character.Humanoid:GetState() == Enum.HumanoidStateType.RunningNoPhysics) and lplr.Character.Humanoid.MoveDirection ~= Vector3.new(0, 0, 0) then
					lplr.Character.HumanoidRootPart.Velocity = Vector3.new(lplr.Character.HumanoidRootPart.Velocity.X, 20, lplr.Character.HumanoidRootPart.Velocity.Z)
				end
			end
		end
	end)
end, function() 
	if bodyvelo then
		bodyvelo:Remove()
	end
	game:GetService("RunService"):UnbindFromRenderStep("Speed")
end, true, function() return "" end, "Makes you go zoom")
speedval = speed.CreateSlider("Speed", 1, 30, function(val) end, 30)
speedjump = speed.CreateToggle("AutoJump", function() end, function() end)

local function getziplinepos()
	local tab = game.Workspace:GetChildren()
	local pos2 = Vector3.new(0, 0, 0)
			for i = 1, #tab do
				local obj = tab[i]
				
					if obj.Name:match("zipline") and obj.Name:match("base") and obj:FindFirstChild("ZiplineDestination")  then
						pos2 = obj.Position
					end

			end
			return pos2 / 3
end

GuiLibrary["RemoveObject"]("FlyOptionsButton")
local OldNoFallFunction
local fly = {["Enabled"] = false}
local flymethod = {["Value"] = "Balloons"}
local flyspeed = {["Value"] = 1}
local flyverticalspeed = {["Value"] = 1}
local flyupanddown = {["Enabled"] = false}
local flybuyballoon = {["Enabled"] = false}
local olddeflate
local flyposy = 0
local flyrequests = 0
local flytime = 60
local flylimit = false
local flyup = false
local flydown = false
local flypress
local flyendpress

local function buyballoons()
	if isAlive() and fly["Enabled"] then
		if getItem("balloon") == nil and flybuyballoon["Enabled"] then
			bedwars["Client"]:Get("BedwarsPurchaseItem"):CallServerAsync({
				shopItem = bedwars["Shop"].getShopItem("balloon")
			}):andThen(function(p11)
				if getItem("balloon") then
					bedwars["BalloonController"]["inflateBalloon"]()
				end
			end)
		end
		if getItem("balloon") then
			bedwars["BalloonController"]["inflateBalloon"]()
		end
	end
end

bedwars["Client"]:WaitFor("BalloonPopped"):andThen(function(p6)
	p6:Connect(function(p7)
		buyballoons()
	end)
end)

fly = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton("Fly", function()
	if flymethod["Value"] == "Balloons" then
		olddeflate = bedwars["BalloonController"]["deflateBalloon"]
		bedwars["BalloonController"]["deflateBalloon"] = function() end
	end
	if isAlive() then
		flyposy = lplr.Character.HumanoidRootPart.Position.Y
		buyballoons()
	end
	flypress = game:GetService("UserInputService").InputBegan:connect(function(input1)
		if flyupanddown["Enabled"] and game:GetService("UserInputService"):GetFocusedTextBox() == nil then
			if input1.KeyCode == Enum.KeyCode.Space then
				flyup = true
			end
			if input1.KeyCode == Enum.KeyCode.LeftShift then
				flydown = true
			end
		end
	end)
	flyendpress = game:GetService("UserInputService").InputEnded:connect(function(input1)
		if input1.KeyCode == Enum.KeyCode.Space then
			flyup = false
		end
		if input1.KeyCode == Enum.KeyCode.LeftShift then
			flydown = false
		end
	end)
	game:GetService("RunService"):BindToRenderStep("Fly", 1, function(delta) 
		if isAlive() and matchState ~= 0 then
			if (flymethod["Value"] == "Balloons" and (lplr.Character:GetAttribute("InflatedBalloons") and lplr.Character:GetAttribute("InflatedBalloons") > 0)) then
				if flyup then
					flyposy = flyposy + (1 * (math.clamp(flyverticalspeed["Value"] - 16, 1, 150) * delta))
				end
				if flydown then
					flyposy = flyposy - (1 * (math.clamp(flyverticalspeed["Value"] - 16, 1, 150) * delta))
				end
				local flypos = (lplr.Character.Humanoid.MoveDirection * (math.clamp(flyspeed["Value"] - 16, 1, 150) * delta))
				lplr.Character.HumanoidRootPart.Transparency = 1
				lplr.Character.HumanoidRootPart.CFrame = lplr.Character.HumanoidRootPart.CFrame + Vector3.new(flypos.X, (flyposy - lplr.Character.HumanoidRootPart.CFrame.p.Y), flypos.Z)
				lplr.Character.HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
			end
		end
	end)
end, function() 
	flyup = false
	flydown = false
	flypress:Disconnect()
	flyendpress:Disconnect()
	game:GetService("RunService"):UnbindFromRenderStep("Fly")
	if flymethod["Value"] == "Balloons" then
		if isAlive() and lplr.Character:GetAttribute("InflatedBalloons") then
			for i = 1, lplr.Character:GetAttribute("InflatedBalloons") do
				olddeflate()
			end
		end
		bedwars["BalloonController"]["deflateBalloon"] = olddeflate
		olddeflate = nil
	else

	end
end, true, function() return " BedWars" end, "Makes you go zoom (Balloons Required) (Will Buy)\nMake sure to turn off speed (hotkeys can help)")
flymethod = fly.CreateDropdown("Mode", {"Balloons"}, function(val)

end)
flyspeed = fly.CreateSlider("Speed", 1, 40, function(val) end)
flyverticalspeed = fly.CreateSlider("Vertical Speed", 1, 40, function(val) end)
flyupanddown = fly.CreateToggle("Y Level", function() end, function() end)
flybuyballoon = fly.CreateToggle("Buy Balloons", function() end, function() end)


local oldpos = Vector3.new(0, 0, 0)
local oldpos2 = Vector3.new(0, 0, 0)
local ScaffoldExpand = {["Value"] = 1}
local ScaffoldHandCheck = {["Enabled"] = false}
local ScaffoldBuyBlocks = {["Enabled"] = false}
local scaffoldallowed = true

Scaffold = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton("Scaffold", function()
	game:GetService("RunService"):BindToRenderStep("Scaffold", 1, function(delta)
		if isAlive() and (ScaffoldHandCheck["Enabled"] and getEquipped()["Type"] == "block" or (not ScaffoldHandCheck["Enabled"])) then
			for i = 1, ScaffoldExpand["Value"] do
				local newpos = getScaffold((lplr.Character.Head.Position + (lplr.Character.Humanoid.MoveDirection * (i * 3.5))) + Vector3.new(0, -6, 0))
				if newpos ~= oldpos then
					if ScaffoldBuyBlocks["Enabled"] and getwool() == nil and scaffoldallowed == true then
						scaffoldallowed = false
						lplr.Character.HumanoidRootPart.Anchored = true
						bedwars["Client"]:Get("BedwarsPurchaseItem"):CallServerAsync({
							shopItem = bedwars["Shop"].getShopItem("wool_white")
						}):andThen(function(p11)
							scaffoldallowed = true
						end)
					end
					if getwool() then
						lplr.Character.HumanoidRootPart.Anchored = false
						scaffoldBlock(newpos)
						oldpos = newpos
					end
				end
			end
		end
	end)
end, function()
	game:GetService("RunService"):UnbindFromRenderStep("Scaffold")
	scaffoldallowed = true
	oldpos = Vector3.new(0, 0, 0)
	oldpos2 = Vector3.new(0, 0, 0)
	if isAlive() then
		lplr.Character.HumanoidRootPart.Anchored = false
	end
end, true)
ScaffoldExpand = Scaffold.CreateSlider("Expand", 1, 8, function(val) end, 1)
ScaffoldBuyBlocks = Scaffold.CreateToggle("Buy Blocks", function() end, function() end)
ScaffoldHandCheck = Scaffold.CreateToggle("Hand Check", function() end, function() end)

if GuiLibrary["Settings"]["ToxicObject"] == nil then
	GuiLibrary["Settings"]["ToxicObject"] = {["Type"] = "Custom", ["List"] = {}}
end
local AutoToxic = {["Enabled"] = false}
local AutoToxicGG = {["Enabled"] = false}
local AutoToxicWin = {["Enabled"] = false}
local AutoToxicFinalKill = {["Enabled"] = false}
local AutoToxicWinStreak = {["Enabled"] = false}
local AutoToxicPhrases = {["RefreshValues"] = function() end}
local AutoToxicOldWin = bedwars["VictoryScreen"].render
local victorysaid = false
bedwars["VictoryScreen"].render = function(winstuff)
    local myTeam = bedwars["ClientStore"]:getState().Game.myTeam;
    if myTeam and myTeam.id == winstuff.props.WinningTeamId and AutoToxic["Enabled"] and victorysaid == false then
		victorysaid = true
		if AutoToxicGG["Enabled"] then
			game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("gg", "All")
		end
		if AutoToxicWin["Enabled"] then
			game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(#GuiLibrary["Settings"]["ToxicObject"]["List"] > 0 and GuiLibrary["Settings"]["ToxicObject"]["List"][math.random(1, #GuiLibrary["Settings"]["ToxicObject"]["List"])] or "EZ L TRASH KIDS : Sponsored by Vˤ̴ape V4 :)", "All")
		end
    end
    return AutoToxicOldWin(winstuff)
end
bedwars["Client"]:WaitFor("EntityDeathEvent"):andThen(function(p6)
	p6:Connect(function(p7)
		if AutoToxic["Enabled"] then
			if p7.fromEntity and p7.fromEntity == game.Players.LocalPlayer.Character then
				local plr = game.Players:GetPlayerFromCharacter(p7.entityInstance)
				if plr and plr.leaderstats.Bed.Value ~= "✅" and AutoToxicFinalKill["Enabled"] then
					game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("L "..(plr.DisplayName or plr.Name)..(AutoToxicWinStreak["Enabled"] and game.Players:GetPlayerFromCharacter(p7.entityInstance):GetAttribute("WinStreak") > 0 and " : "..game.Players:GetPlayerFromCharacter(p7.entityInstance):GetAttribute("WinStreak").." winstreak" or ""), "All")
				end
			end
		end
	end)
end)
AutoToxic = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton("AutoToxic", function() end, function() end, true)
AutoToxicGG = AutoToxic.CreateToggle("AutoGG", function() end, function() end, true)
AutoToxicWin = AutoToxic.CreateToggle("Win", function() end, function() end, true)
AutoToxicFinalKill = AutoToxic.CreateToggle("Final Kill", function() end, function() end, true)
AutoToxicWinStreak = AutoToxic.CreateToggle("WinStreak", function() end, function() end, false)
AutoToxicPhrases = AutoToxic.CreateTextList("ToxicList", "phrase (win)", function(user)
	table.insert(GuiLibrary["Settings"]["ToxicObject"]["List"], user)
	AutoToxicPhrases["RefreshValues"](GuiLibrary["Settings"]["ToxicObject"]["List"])
end, function(num) 
	table.remove(GuiLibrary["Settings"]["ToxicObject"]["List"], num) 
	AutoToxicPhrases["RefreshValues"](GuiLibrary["Settings"]["ToxicObject"]["List"])
end)


--local BuyArrows = {["Enabled"] = false}
--local BowAura = {["Enabled"] = false}
--local bowaurarange = {["Value"] = 50}
--local BowDelay2 = {["Value"] = 5}
--local BowTargets = {["Value"] = 1}
--BowAura = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton("BowAura", function()
	--spawn(function()
		--repeat
		--	wait(BowDelay2["Value"] / 10)
		--	if isAlive() and getEquipped()["Type"] == "bow" then
			--	local targettable = {}
			--	local targetsize = 0
			--	local plrs = GetAllNearestHumanoidToPosition(bowaurarange["Value"], BowTargets["Value"])
			--	for i,v in pairs(plrs) do
			--		wait(0.03)
			--		local bowpos = bedwars["ProjectilePosition"]()
				--	if isPlayerTargetable(v, true, true) and v.Character and v.Character:FindFirstChild("Head") and vischeck(bowpos, v.Character.Head.Position, {lplr.Character, v.Character}) then
			--			targettable[v.Name] = {
				--			["UserId"] = v.UserId,
				--			["Health"] = v.Character.Humanoid.Health,
				--			["MaxHealth"] = v.Character.Humanoid.MaxHealth
					--	}
					--	targetsize = targetsize + 1
					--	game:GetService("ReplicatedStorage").rbxts_include.node_modules.net.out._NetManaged[bedwars["FireProjectile"]]:InvokeServer(getEquipped()["Object"], bowpos, (bowpos - v.Character.Head.Position))
				--	end
			--	end
			--	targetinfo.UpdateInfo(targettable, targetsize)
		--	end
		--until BowAura["Enabled"] == false
--	end)
--end, function() end, true)
--bowaurarange = BowAura.CreateSlider("Bow Range", 1, 70, function(val) end, 70)
--BowDelay2 = BowAura.CreateSlider("Bow Delay", 1, 20, function(val) end, 5)
--BowTargets = BowAura.CreateSlider("Bow Targets", 1, 20, function(val) end, 1)]]

local NoFall = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton("NoFall", function()
	OldNoFallFunction = bedwars["damageTable"]["requestSelfDamage"]
	bedwars["damageTable"]["requestSelfDamage"] = function() end
end, function()
	bedwars["damageTable"]["requestSelfDamage"] = OldNoFallFunction
end, true, function() return "" end, "Prevents taking fall damage.")

local healthColorToPosition = {
	[Vector3.new(Color3.fromRGB(255, 28, 0).r,
  Color3.fromRGB(255, 28, 0).g,
  Color3.fromRGB(255, 28, 0).b)] = 0.1;
	[Vector3.new(Color3.fromRGB(250, 235, 0).r,
  Color3.fromRGB(250, 235, 0).g,
  Color3.fromRGB(250, 235, 0).b)] = 0.5;
	[Vector3.new(Color3.fromRGB(27, 252, 107).r,
  Color3.fromRGB(27, 252, 107).g,
  Color3.fromRGB(27, 252, 107).b)] = 0.8;
}
local min = 0.1
local minColor = Color3.fromRGB(255, 28, 0)
local max = 0.8
local maxColor = Color3.fromRGB(27, 252, 107)

local function HealthbarColorTransferFunction(healthPercent)
	if healthPercent < min then
		return minColor
	elseif healthPercent > max then
		return maxColor
	end


	local numeratorSum = Vector3.new(0,0,0)
	local denominatorSum = 0
	for colorSampleValue, samplePoint in pairs(healthColorToPosition) do
		local distance = healthPercent - samplePoint
		if distance == 0 then
			
			return Color3.new(colorSampleValue.x, colorSampleValue.y, colorSampleValue.z)
		else
			local wi = 1 / (distance*distance)
			numeratorSum = numeratorSum + wi * colorSampleValue
			denominatorSum = denominatorSum + wi
		end
	end
	local result = numeratorSum / denominatorSum
	return Color3.new(result.x, result.y, result.z)
end

local BedESPFolder = Instance.new("Folder")
BedESPFolder.Name = "BedESPFolder"
BedESPFolder.Parent = GuiLibrary["MainGui"]
local BedESPColor = {["Value"] = 0.44}
local BedESPTransparency = {["Value"] = 1}
local BedESPOnTop = {["Enabled"] = true}
local BedESP = GuiLibrary["ObjectsThatCanBeSaved"]["RenderWindow"]["Api"].CreateOptionsButton("BedESP", function() 
	game:GetService("RunService"):BindToRenderStep("BedESP", 500, function()
		if bedwars["BedTable"] then
			for i,plr in pairs(bedwars["BedTable"]) do
					local thing
					if plr ~= nil and BedESPFolder:FindFirstChild(plr.Name..tostring(plr.Covers.BrickColor)) then
						thing = BedESPFolder[plr.Name..tostring(plr.Covers.BrickColor)]
						for bedespnumber, bedesppart in pairs(thing:GetChildren()) do
							bedesppart.Visible = false
						end
					end
					
					if plr ~= nil then
						if BedESPFolder:FindFirstChild(plr.Name..tostring(plr.Covers.BrickColor)) == nil then
							local Bedfolder = Instance.new("Folder")
							Bedfolder.Name = plr.Name..tostring(plr.Covers.BrickColor)
							Bedfolder.Parent = BedESPFolder
							thing = Bedfolder
							for bedespnumber, bedesppart in pairs(plr:GetChildren()) do
								local boxhandle = Instance.new("BoxHandleAdornment")
								boxhandle.Size = bedesppart.Size + Vector3.new(.01, .01, .01)
								boxhandle.AlwaysOnTop = true
								boxhandle.ZIndex = 10
								boxhandle.Visible = true
								boxhandle.Color3 = bedesppart.Color
								boxhandle.Name = bedespnumber
								boxhandle.Parent = Bedfolder
							end
						end
						for bedespnumber, bedesppart in pairs(thing:GetChildren()) do
							bedesppart.Visible = true
							if plr:GetChildren()[bedespnumber] then
								bedesppart.Adornee = plr:GetChildren()[bedespnumber]
							else
								bedesppart.Adornee = nil
							end
						end
					end
			end
		end
	end)
end, function() game:GetService("RunService"):UnbindFromRenderStep("BedESP") BedESPFolder:ClearAllChildren() end, true, function() return "" end, "testing")

GuiLibrary["RemoveObject"]("NameTagsOptionsButton")
local NameTagsFolder = Instance.new("Folder")
NameTagsFolder.Name = "NameTagsFolder"
NameTagsFolder.Parent = GuiLibrary["MainGui"]
players.PlayerRemoving:connect(function(plr)
	if NameTagsFolder:FindFirstChild(plr.Name) then
		NameTagsFolder[plr.Name]:Remove()
	end
end)
local NameTagsColor = {["Value"] = 0.44}
local NameTagsDisplayName = {["Enabled"] = false}
local NameTagsHealth = {["Enabled"] = false}
local NameTagsDistance = {["Enabled"] = false}
local NameTagsShowInventory = {["Enabled"] = false}
local NameTags = GuiLibrary["ObjectsThatCanBeSaved"]["RenderWindow"]["Api"].CreateOptionsButton("NameTags", function() 
	game:GetService("RunService"):BindToRenderStep("NameTags", 500, function()
		for i,plr in pairs(players:GetChildren()) do
				local thing
				if NameTagsFolder:FindFirstChild(plr.Name) then
					thing = NameTagsFolder[plr.Name]
					thing.Visible = false
				else
					thing = Instance.new("TextLabel")
					thing.BackgroundTransparency = 0.5
					thing.BackgroundColor3 = Color3.new(0, 0, 0)
					thing.BorderSizePixel = 0
					thing.Visible = false
					thing.RichText = true
					thing.Name = plr.Name
					thing.Font = (GuiLibrary["ObjectsThatCanBeSaved"]["VapeOptionsSmooth fontToggle"]["Api"]["Enabled"] and Enum.Font.SourceSans or Enum.Font.Sarpanch)
					thing.TextSize = 14
					if plr.Character and plr.Character:FindFirstChild("Humanoid") and plr.Character:FindFirstChild("HumanoidRootPart") then
						local rawText = (NameTagsDisplayName["Enabled"] and plr.DisplayName ~= nil and plr.DisplayName or plr.Name)
						if NameTagsHealth["Enabled"] then
							rawText = (NameTagsDisplayName["Enabled"] and plr.DisplayName ~= nil and plr.DisplayName or plr.Name).." "..math.floor(plr.Character.Humanoid.Health)
						end
						local color = HealthbarColorTransferFunction(plr.Character.Humanoid.Health / plr.Character.Humanoid.MaxHealth)
						local modifiedText = (NameTagsDistance["Enabled"] and isAlive() and '<font color="rgb(85, 255, 85)">[</font>'..math.floor((lplr.Character.HumanoidRootPart.Position - plr.Character.HumanoidRootPart.Position).magnitude)..'<font color="rgb(85, 255, 85)">]</font> ' or '')..(NameTagsDisplayName["Enabled"] and plr.DisplayName ~= nil and plr.DisplayName or plr.Name)..(NameTagsHealth["Enabled"] and ' <font color="rgb('..tostring(math.floor(color.R * 255))..','..tostring(math.floor(color.G * 255))..','..tostring(math.floor(color.B * 255))..')">'..math.floor(plr.Character.Humanoid.Health).."</font>" or '')
						local nametagSize = game:GetService("TextService"):GetTextSize(rawText, thing.TextSize, thing.Font, Vector2.new(100000, 100000))
						thing.Size = UDim2.new(0, nametagSize.X + 4, 0, nametagSize.Y)
						thing.Text = modifiedText
					else
						local nametagSize = game:GetService("TextService"):GetTextSize(plr.Name, thing.TextSize, thing.Font, Vector2.new(100000, 100000))
						thing.Size = UDim2.new(0, nametagSize.X + 4, 0, nametagSize.Y)
						thing.Text = plr.Name
					end
					thing.TextColor3 = tostring(plr.TeamColor) ~= "White" and plr.TeamColor.Color or (GuiLibrary["ObjectsThatCanBeSaved"]["Use colorToggle"]["Api"]["Enabled"] and table.find(GuiLibrary["FriendsObject"]["Friends"], plr.Name) and Color3.fromHSV(GuiLibrary["ObjectsThatCanBeSaved"]["Friends ColorSliderColor"]["Api"]["Value"], 1, 1)) or Color3.fromHSV(NameTagsColor["Value"], 1, 1)
					thing.Parent = NameTagsFolder
					local hand = Instance.new("ImageLabel")
					hand.Size = UDim2.new(0, 30, 0, 30)
					hand.Name = "Hand"
					hand.BackgroundTransparency = 1
					hand.Position = UDim2.new(0, -30, 0, -30)
					hand.Image = ""
					hand.Parent = thing
					local helmet = hand:Clone()
					helmet.Name = "Helmet"
					helmet.Position = UDim2.new(0, 5, 0, -30)
					helmet.Parent = thing
					local chest = hand:Clone()
					chest.Name = "Chestplate"
					chest.Position = UDim2.new(0, 35, 0, -30)
					chest.Parent = thing
					local boots = hand:Clone()
					boots.Name = "Boots"
					boots.Position = UDim2.new(0, 65, 0, -30)
					boots.Parent = thing
				end
				
				if isPlayerTargetable(plr, false, false) then
					local headPos, headVis = cam:WorldToViewportPoint((plr.Character.HumanoidRootPart:GetRenderCFrame() * CFrame.new(0, plr.Character.Head.Size.Y + plr.Character.HumanoidRootPart.Size.Y, 0)).Position)
					headPos = headPos * (1 / GuiLibrary["MainRescale"].Scale)
					
					if headVis then
						local inventory = bedwars["getInventory"](plr)
						local blocksaway = math.floor((lplr.Character.HumanoidRootPart.Position - plr.Character.HumanoidRootPart.Position).magnitude / 3)
						local rawText = (NameTagsDistance["Enabled"] and isAlive() and "["..blocksaway.."] " or "")..(NameTagsDisplayName["Enabled"] and plr.DisplayName ~= nil and plr.DisplayName or plr.Name)..(NameTagsHealth["Enabled"] and " "..math.floor(plr.Character.Humanoid.Health) or "")
						local color = HealthbarColorTransferFunction(plr.Character.Humanoid.Health / plr.Character.Humanoid.MaxHealth)
						local modifiedText = (NameTagsDistance["Enabled"] and isAlive() and '<font color="rgb(85, 255, 85)">[</font><font color="rgb(255, 255, 255)">'..blocksaway..'</font><font color="rgb(85, 255, 85)">]</font> ' or '')..(NameTagsDisplayName["Enabled"] and plr.DisplayName ~= nil and plr.DisplayName or plr.Name)..(NameTagsHealth["Enabled"] and ' <font color="rgb('..tostring(math.floor(color.R * 255))..','..tostring(math.floor(color.G * 255))..','..tostring(math.floor(color.B * 255))..')">'..math.floor(plr.Character.Humanoid.Health).."</font>" or '')
						local nametagSize = game:GetService("TextService"):GetTextSize(rawText, thing.TextSize, thing.Font, Vector2.new(100000, 100000))
						thing.Size = UDim2.new(0, nametagSize.X + 4, 0, nametagSize.Y)
						thing.Text = modifiedText
						thing.TextColor3 = tostring(plr.TeamColor) ~= "White" and plr.TeamColor.Color or (GuiLibrary["ObjectsThatCanBeSaved"]["Use colorToggle"]["Api"]["Enabled"] and table.find(GuiLibrary["FriendsObject"]["Friends"], plr.Name) and Color3.fromHSV(GuiLibrary["ObjectsThatCanBeSaved"]["Friends ColorSliderColor"]["Api"]["Value"], 1, 1)) or Color3.fromHSV(NameTagsColor["Value"], 1, 1)
						thing.Visible = headVis
						thing.Position = UDim2.new(0, headPos.X - thing.Size.X.Offset / 2, 0, (headPos.Y - thing.Size.Y.Offset) - 36)
						if inventory.hand then
							thing.Hand.Image = bedwars["getIcon"](inventory.hand, NameTagsShowInventory["Enabled"])
						end
						if inventory.armor[4] then
							thing.Helmet.Image = bedwars["getIcon"](inventory.armor[4], NameTagsShowInventory["Enabled"])
						end
						if inventory.armor[5] then
							thing.Chestplate.Image = bedwars["getIcon"](inventory.armor[5], NameTagsShowInventory["Enabled"])
						end
						if inventory.armor[6] then
							thing.Boots.Image = bedwars["getIcon"](inventory.armor[6], NameTagsShowInventory["Enabled"])
						end
					end
				end
			end

	end)
end, function() game:GetService("RunService"):UnbindFromRenderStep("NameTags") NameTagsFolder:ClearAllChildren() end, true)
NameTagsColor = NameTags.CreateColorSlider("Player Color", function(val) end)
NameTagsDisplayName = NameTags.CreateToggle("Use Display Name", function() end, function() end)
NameTagsHealth = NameTags.CreateToggle("Health", function() end, function() end)
NameTagsDistance = NameTags.CreateToggle("Distance", function() end, function() end)
NameTagsShowInventory = NameTags.CreateToggle("Show Inventory", function() end, function() end)
